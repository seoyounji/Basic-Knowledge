***

### **Array  VS  Dynamic Array  VS  LinkedList**

***

* Array

  * 처음 선언할 때 배열의 크기를 고정해야 함

  * 논리적 저장순서와 물리적 저장순서가 일치하고 메모리 공간상에서 연속적으로 존재함

  * 인덱스로 해당 원소에 접근할 수 있어서 데이터 탐색 시간 복잡도는 O(1)

  * 데이터 삽입, 삭제 시 배열에 빈 부분이 생기지 않도록 shift 해줘야하므로 최악의 경우 시간 복잡도는 O(N)

  * Compile time에 메모리에 선언되므로 정적 메모리 할당

    ​          

* Dynamic Array

  * java에서는 ArrayList , C++에서는 Vector

  * 처음 선언할 때 배열의 크기를 고정하지 않는, Array의 불편함을 해소하기 위해 나온 자료구조

  * 설정한 배열 크기를 넘으면 1.5배 크기의 배열을 새로 할당받아 기존 배열에 저장되어 있던 값을 새로 할당한 배열에 복사

  * 인덱스로 해당 원소에 접근할 수 있어서 데이터 탐색 시간 복잡도는 O(1)

  * 데이터 삽입, 삭제 시 배열에 빈 부분이 생기지 않도록 shift 해줘야하므로 최악의 경우 시간 복잡도는 O(N)

    ​          

* LinkedList

  * 논리적 저장순서와 물리적 저장순서가 다르기 때문에 데이터 검색 시 처음 노드부터 일일히 살펴봐야 함. 그러므로 데이터 탐색 시간 복잡도는 O(N)
  * 메모리 공간 상에서 각 노드(데이터 값과 다음 노드의 주소값이 저장되어 있음)들이 연속적으로 이루어져 있지 않고 흩어져 있으며 사용자는 제일 첫번째 노드의 주소값만 알고 있는 상태
  * 데이터 삽입, 삭제 시 데이터 탐색과 더불어 작업을 완료하기까지 걸리는 시간 복잡도는 O(N). 그럼에도 불구하고 Array나 Dynamic Array보다 빠른 성능을 가짐
  * Run time에 메모리에 선언되므로 동적 메모리 할당
  * 단일 링크드리스트는 뒤의 노드만 가리키고 다중 링크드리스트는 앞뒤 노드를 모두 가리킴

​          

삽입과 삭제가 빈번하게 일어난다면 LinkedList를 사용할 것

데이터 검색이 빈번하게 일어난다면 (Dynamic) Array를 사용할 것

​            

***

### **Stack  VS  Queue**

***

* Stack

  * LIFO (Last In First Out) 구조

  * 맨 위에 데이터 삽입(push)  /  맨 위 데이터 삭제(pop)  /  맨 위 데이터 읽기(peek)

  * 데이터 삽입 및 삭제 시 시간 복잡도 O(1)  /  데이터 탐색 시 시간 복잡도 O(N)

  * 함수의 콜  /  문자열 역순 출력  /  연산자 후위 표기법 등에 사용

    ​         

* Queue

  * FIFO (First In First Out) 구조

  * 맨 뒤에 데이터 삽입(Enqueue)  /  맨 위 데이터 삭제(Dequeue)

  * 데이터 삽입 및 삭제 시 시간 복잡도 O(1)  /  데이터 탐색 시 시간 복잡도 O(N)

  * 버퍼  /  BFS 등에 사용

    ​          

2개의 stack으로 queue를 구현하려면 일단 데이터를 모두 stack에 넣은다음 하나씩 빼면서 다시 다른 stack에 넣고 2번째 스택에서 다시 데이터를 하나씩 빼면 된다.

​                  

***

### **Tree**

***

일반 배열도 있는데 데이터를 저장할 때 이 트리 구조를 쓰는 이유가 뭘까?         

위에 있듯이 일반 배열에선 삽입이나 삭제를 하는데 O(N)의 시간이 걸린다.       

하지만 트리 구조에서는 (편향 트리가 아닌 일반적인 트리에서) 시간 복잡도가 O(log N) 으로 줄어든다!       

트리는 비선형 자료구조이며 루트 노드를 제외한 모든 노드는 단 하나의 부모 노드만을 가진다.             

​                  

<img src="images/tree.jpg" title="tree" alt="tree"></img>

* 포화 이진 트리 (Full Binary Tree) : 모든 레벨이 무조건 꽉 찬 이진 트리. 따라서 높이가 h인 포화 이진 트리에 있는 노드의 수는 2^h - 1 이다. 
* 완전 이진 트리 (Complete Binary Tree) : 왼쪽에서 오른쪽으로 차곡차곡 채워진 이진 트리. 노드의 수가 N개 일 때 완전 이진 트리의 높이는 log2(N)을 계산한 뒤 결과값이 정수가 아닌 경우 올림하면 된다.

​            

* 순회
  * 전위 순회 (preorder)


## **Array  VS  Dynamic Array  VS  LinkedList**

------------------

* Array

  * 처음 선언할 때 배열의 크기를 고정해야 함

  * 논리적 저장순서와 물리적 저장순서가 일치하고 메모리 공간상에서 연속적으로 존재함

  * 인덱스로 해당 원소에 접근할 수 있어서 데이터 탐색 시간 복잡도는 O(1)

  * 데이터 삽입, 삭제 시 배열에 빈 부분이 생기지 않도록 shift 해줘야하므로 최악의 경우 시간 복잡도는 O(N)

  * Compile time에 메모리에 선언되므로 정적 메모리 할당

    ​          

* Dynamic Array

  * java에서는 ArrayList , C++에서는 Vector

  * 처음 선언할 때 배열의 크기를 고정하지 않는, Array의 불편함을 해소하기 위해 나온 자료구조

  * 설정한 배열 크기를 넘으면 1.5배 크기의 배열을 새로 할당받아 기존 배열에 저장되어 있던 값을 새로 할당한 배열에 복사

  * 인덱스로 해당 원소에 접근할 수 있어서 데이터 탐색 시간 복잡도는 O(1)

  * 데이터 삽입, 삭제 시 배열에 빈 부분이 생기지 않도록 shift 해줘야하므로 최악의 경우 시간 복잡도는 O(N)

    ​          

* LinkedList

  * 논리적 저장순서와 물리적 저장순서가 다르기 때문에 데이터 검색 시 처음 노드부터 일일히 살펴봐야 함. 그러므로 데이터 탐색 시간 복잡도는 O(N)
  * 메모리 공간 상에서 각 노드(데이터 값과 다음 노드의 주소값이 저장되어 있음)들이 연속적으로 이루어져 있지 않고 흩어져 있으며 사용자는 제일 첫번째 노드의 주소값만 알고 있는 상태
  * 데이터 삽입, 삭제 시 데이터 탐색과 더불어 작업을 완료하기까지 걸리는 시간 복잡도는 O(N). 그럼에도 불구하고 Array나 Dynamic Array보다 빠른 성능을 가짐
  * Run time에 메모리에 선언되므로 동적 메모리 할당
  * 단일 링크드리스트는 뒤의 노드만 가리키고 다중 링크드리스트는 앞뒤 노드를 모두 가리킴

​          

삽입과 삭제가 빈번하게 일어난다면 LinkedList를 사용할 것

데이터 검색이 빈번하게 일어난다면 (Dynamic) Array를 사용할 것

​             

## **Stack  VS  Queue**

--------------------------------


